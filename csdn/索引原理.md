一.索引原理：       为认识索引工作原理，首先有必要对数据表的基本结构作一次全面的复习。    当一个新表被创建之时，系统将在磁盘中分配一段以8K为单
位的连续空间，当字段的值从内存写入磁盘时，就在这一既定空间随机保存，当一个8K用完的时候，SQLS指针会自动分配一个8K的空间。这里，每个8K空间被称为一个
数据页（Page），又名页面或数据页面，并分配从0-7的页号,每个文件的第0页记录引导信息，叫文件头（File
header）；每8个数据页（64Ｋ）的组合形成扩展区（Extent），称为扩展。全部数据页的组合形成堆（Heap）。 SQLS规定行不能跨越数据页，所以，
每行记录的最大数据量只能为8K。这就是char和varchar这两种字符串类型容量要限制在8K以内的原因，存储超过8K的数据应使用text类型，实际上，te
xt类型的字段值不能直接录入和保存，它只是存储一个指针，指向由若干8K的文本数据页所组成的扩展区，真正的数据正是放在这些数据页中。
页面有空间页面和数据页面之分。 当一个扩展区的8个数据页中既包含了空间页面又包括了数据或索引页面时，称为混合扩展（Mixed
Extent）,每张表都以混合扩展开始；反之，称为一致扩展（Uniform Extent），专门保存数据及索引信息。 表被创建之时，SQLS在混合扩展中为其
分配至少一个数据页面，随着数据量的增长，SQLS可即时在混合扩展中分配出7个页面，当数据超过8个页面时，则从一致扩展中分配数据页面。
空间页面专门负责数据空间的分配和管理，包括：PFS页面（Page free
space）：记录一个页面是否已分配、位于混合扩展还是一致扩展以及页面上还有多少可用空间等信息；GAM页面（Global allocation
map）和SGAM页面(Secodary global allocation
map)：用来记录空闲的扩展或含有空闲页面的混合扩展的位置。SQLS综合利用这三种类型的页面文件在必要时为数据表创建新空间；
实际上，您可以把索引理解为一种特殊的目录。微软的SQL SERVER提供了两种索引： 1.聚集索引
其实，我们的汉语字典的正文本身就是一个聚集索引。比如，我们要查“安”字，就会很自然地翻开字典的前几页，因为“安”的拼音是“an.
字典的正文部分本身就是一个目录，您不需要再去查其他目录来找到您需要找的内容。 我们把这种正文内容本身就是一种按照一定规则排列的目录称为“聚集索引”。
2.非聚集索引 如果您认识某个字，您可以快速地从自动中查到这个字。但您也可能会遇到您不认识的字，不知道它的发音，这时候，您就不能按照刚才的方
法找到您要查的字，而需要去根据“偏旁部首”查到您要找的字，然后根据这个字后的页码直接翻到某页来找到您要找的字。但您结合“部首
目录”和“检字表”而查到的字的排序并不是真正的正文的排序方法，比如您查“张”字，我们可以看到在查部首之后的检字表中“张”的页
码是672页，检字表中“张”的上面是“驰”字，但页码却是63页，“张”的下面是“弩”字，页面是390页。很显然，这些字并不是真正的分
别位于“张”字的上下方，现在您看到的连续的“驰、张、弩”三字实际上就是他们在非聚集索引中的排序，是字典正文中的字在非聚集索引
中的映射。我们可以通过这种方式来找到您所需要的字，但它需要两个过程，先找到目录中的结果，然后再翻到您所需要的页码。
我们把这种目录纯粹是目录，正文纯粹是正文的排序方式称为“非聚集索引”。 通过以上例子，我们可以理解到什么是“聚集索引”和“非聚集索引”。   二。实例分析：
下面我们就来看一下在200万条数据量的情况下各种查询的速度表现（以25万条数据为例说明）   create database index_Test1
--创建测试用的索引数据库 GO use index_Test1 GO create table IndexTable1 (    gid int
identity(1,1) primary key,    data datetime,    creater varchar(100) not null,
title varchar(100) not null,  ) \--插入数据 declare @i int set @i=1 while
@i<=2000000 begin   insert into IndexTable1(data,creater,title)
values(DATEADD(day, @i, getdate()),'mfm','这是测试索引的例子')   set @i=@i+1 end
\--默认情况下查询前250000条数据的时间 declare @timediff datetime select @timediff=getdate()
select top 250000 * from IndexTable1 select datediff(ms,@timediff,GetDate())
as 耗时 \--在主键上建立聚集索引，在data上建立非聚集索引(非常慢) create CLUSTERED index gid_index on
IndexTable1(data) \--也可以利用以下方法修改主健为非聚集索引 alter   table   IndexTable1  add
constraint   pk_dr   primary   key   nonclustered(gid)  \--删除已存在的索引 drop index
IndexTable1.gid_index   经过测试，总结如下：
1.在默认情况下，即以gid为主健时，系统自动生成聚集索引，查询25w数据花了3382ms
2.以gid为主健聚集索引，data建立为非聚集索引时，查询25w数据花了5586ms
3.取消主健取集索引，建立data为取集索引时，查询25w数据花了2274ms
本人机器配置是:本本迅弛双核1.6g,512m内存，独显128m，大家可以按照以上方法去一一测试。

